# Дорожная карта улучшений торговых стратегий

Документ описывает запланированные улучшения для повышения прибыльности и устойчивости бота. Связан с текущей стратегией: [PROFITABILITY_STRATEGY.md](PROFITABILITY_STRATEGY.md).

**Эталонная модель для тестов:** все новые изменения тестируются на [rf_BTCUSDT_15_15m.pkl](ml_models/rf_BTCUSDT_15_15m.pkl). Подробности: [TESTING_REFERENCE_MODEL.md](TESTING_REFERENCE_MODEL.md).

---

## Текущее состояние системы

| Компонент | Описание |
|-----------|----------|
| **MLStrategy** | Одна модель 15m, порог уверенности, фильтр стабильности, ATR-based SL/TP |
| **MTF** | Фильтр по 1h + вход по 15m, режимы выравнивания (strict/relaxed) |
| **Гипотезы** | `hypothesis_test.py`: dynamic (breakeven + trailing), fixed_25_10, fixed_15_5, fixed_10_10 |
| **Оптимизатор** | `auto_strategy_optimizer.py` — выбор MTF vs single по символу, сохранение в `best_strategies_*.json` |
| **Бэктесты** | `backtest_ml_strategy.py`, `backtest_mtf_strategy.py`, `backtest_tp_reentry_delay.py` |

---

## Улучшения (список)

### 1. Фильтр по волатильности (торговать только когда «есть движение»)

**Цель:** Торговать только когда волатильность в «рабочем» диапазоне — не флэт (мало движения) и не паника (слишком большой шум). Иными словами: входить только когда «есть движение».

**Описание:**
- Считать **ATR(14)** или **BB width** (ширину Bollinger Bands) на таймфрейме **1h**.
- Входить только если волатильность попадает в заданный диапазон: не слишком низкая (флэт) и не слишком высокая (паника).
- В бэктесте **перебирать пороги** (например, 0.3%–2.0% для ATR в процентах от цены) и смотреть **PnL / Sharpe** по каждому варианту; выбрать лучшую пару min/max по символам или глобально.

**Где внедрить (варианты):**
- **Обёртка над MLStrategy** — отдельный класс/функция, которая принимает сигнал от MLStrategy и пропускает его дальше только если ATR 1h в диапазоне.
- **Фильтр в `trading_loop`** — перед открытием позиции проверять ATR(14) или BB width на 1h; при выходе за диапазон не открывать сделку.

**Файлы для изменений:**
- `backtest_ml_strategy.py` или `backtest_mtf_strategy.py` — расчёт ATR(14) или BB width на 1h, фильтр перед открытием позиции; перебор порогов 0.3–2.0% и вывод PnL/Sharpe.
- При успехе: `bot/trading_loop.py` — тот же фильтр в live; `bot/config.py` — параметры `atr_filter_enabled`, `atr_min_pct`, `atr_max_pct` (и при использовании BB — `bb_width_period`, `bb_width_min`, `bb_width_max`).

**Приоритет:** Высокий  
**Оценка трудозатрат:** 1–2 дня  
**Зависимости:** Нет  

**Статус:** ⚠️ **Реализовано, но показало ухудшение показателей** — не рекомендуется к использованию. Конфиг: `atr_filter_enabled`, `atr_min_pct`, `atr_max_pct` в [bot/config.py](bot/config.py). Бэктест: флаг `--atr-filter`, `--atr-min`, `--atr-max` в [backtest_ml_strategy.py](backtest_ml_strategy.py). Live: проверка в [bot/trading_loop.py](bot/trading_loop.py) перед открытием позиции. **По умолчанию отключен** (`atr_filter_enabled: false`). При тестировании показал снижение прибыльности, возможно из-за пропуска прибыльных сигналов в периоды низкой/высокой волатильности.

---

### 2. Тайм-фильтр (торговые часы)

**Цель:** Ограничить торговлю часами с нормальной ликвидностью и объёмом, снизить входы в «мёртвые» сессии.

**Описание:**
- Параметры: время начала и конца в UTC (например, 08:00–20:00).
- В бэктесте: сигналы вне окна не приводят к открытию позиции.
- Сравнить метрики: «все часы» vs «только окно».

**Файлы для изменений:**
- `backtest_ml_strategy.py`, `backtest_mtf_strategy.py` — проверка `datetime` входа в диапазон.
- `bot/trading_loop.py` — проверка перед открытием.
- `bot/config.py` — `trading_hours_enabled`, `trading_hour_start_utc`, `trading_hour_end_utc`.

**Приоритет:** Средний  
**Оценка трудозатрат:** 0.5–1 день  
**Зависимости:** Нет

---

### 3. Условный trailing (частичный TP + трейлинг)

**Цель:** Зафиксировать часть прибыли по первой цели, затем вести трейлинг по остатку, чтобы не отдавать уже заработанное.

**Описание:**
- Первая цель: например +1.5% — переводим SL в breakeven или закрываем часть позиции.
- После достижения порога активации (например, +3%) — включать классический trailing (как в `hypothesis_test` dynamic).
- Параметры: `partial_tp_pct`, `trailing_activation_pct`, `trailing_distance_pct`.

**Файлы для изменений:**
- `hypothesis_test.py` — новый режим, например `dynamic_partial_tp`, или расширение `HypothesisSimulator`.
- `backtest_ml_strategy.py` / `MLBacktestSimulator` — при наличии единого симулятора выхода: логика частичного TP + трейлинг.
- Документация: добавить описание режима в этот файл и в PROFITABILITY_STRATEGY.md.

**Приоритет:** Высокий  
**Оценка трудозатрат:** 1–2 дня  
**Зависимости:** Нет  

**Статус:** ⚠️ **Реализовано, но показало ухудшение показателей** — не рекомендуется к использованию. 
- Бэктест: параметры `--partial-tp`, `--partial-tp-pct`, `--trailing-activation-pct`, `--trailing-distance-pct` в [backtest_ml_strategy.py](backtest_ml_strategy.py).
- Режим `dynamic_partial_tp` добавлен в [hypothesis_test.py](hypothesis_test.py).
- Логика: при достижении `partial_tp_pct` (по умолчанию 1.5%) SL переводится в breakeven; при достижении `trailing_activation_pct` (по умолчанию 3.0%) активируется trailing stop с расстоянием `trailing_distance_pct` (по умолчанию 2.0%).

**Результаты тестирования на rf_BTCUSDT_15_15m.pkl (30 дней):**
- **Без частичного TP:** PnL +79.74%, Win Rate 60.13%, Profit Factor 2.30, Sharpe 5.72, Max DD 5.58%, сделок 153
- **С частичным TP:** PnL +61.01% (-18.73%), Win Rate 51.89% (-8.24%), Profit Factor 1.88 (-0.42), Sharpe 4.22 (-1.50), Max DD 8.26% (+2.68%), сделок 185 (+32)
- **Вывод:** Частичный TP увеличил количество сделок и убыточных сделок, снизил Win Rate и общую прибыльность. Возможные причины: слишком ранний breakeven (1.5%) приводит к преждевременным закрытиям, trailing stop на расстоянии 2.0% слишком близко и срабатывает на коррекциях.

---

### 4. Три таймфрейма (добавление 4h)

**Цель:** Усилить фильтр тренда: вход только при согласованности 4h, 1h и 15m; при согласии — возможность увеличить размер или расширить TP.

**Описание:**
- Текущий MTF: 1h (фильтр) + 15m (вход). Добавить 4h как «тренд высшего порядка».
- Правила: при совпадении направления 4h и 1h с 15m — разрешать вход и опционально повышать долю риска или целевой TP; при несовпадении 4h — не входить или уменьшать размер.
- Модель 4h: либо отдельная обученная модель, либо эвристика (например, EMA 50/200 на 4h).

**Файлы для изменений:**
- `bot/ml/mtf_strategy.py` — класс `MultiTimeframeMLStrategy`: добавление 4h, флаги `require_4h_alignment`, `boost_size_on_4h_align`.
- Обучение/подбор моделей 4h (если решено использовать ML на 4h).
- `auto_strategy_optimizer.py` — учёт 4h в переборе комбинаций (если нужно).
- `bot/config.py` — параметры 4h (вкл/выкл, пороги).

**Приоритет:** Средний  
**Оценка трудозатрат:** 2–3 дня  
**Зависимости:** Модели/данные 4h  

**Статус:** ✅ Реализовано с эвристикой (EMA 50/200).
- Добавлена поддержка 4h таймфрейма в [bot/ml/mtf_strategy.py](bot/ml/mtf_strategy.py) с эвристикой EMA 50/200.
- Логика: при включении `enable_4h` проверяется направление тренда на 4h; при `require_4h_alignment=True` вход разрешен только при согласии всех трех таймфреймов (4h, 1h, 15m).
- При согласии всех трех таймфреймов: опционально увеличивается размер позиции (`boost_size_on_4h_align`, множитель `size_boost_factor`) или расширяется TP (`boost_tp_on_4h_align`, множитель `tp_boost_factor`).
- Бэктест: параметры `--enable-4h`, `--no-require-4h-alignment`, `--boost-size-on-4h`, `--boost-tp-on-4h`, `--size-boost-factor`, `--tp-boost-factor` в [backtest_mtf_strategy.py](backtest_mtf_strategy.py).

---

### 5. Адаптивный порог уверенности по ATR

**Цель:** В высокой волатильности чуть снижать порог уверенности (больше сигналов в движении), в низкой — повышать (меньше шума).

**Описание:**
- В `generate_signal`: расчёт множителя порога от ATR (например, нормализация к медианному ATR за 30 дней).
- Формула-пример: `effective_threshold = base_threshold * (1 + k * (atr_median - atr_current) / atr_median)`, с ограничением по min/max.
- В бэктесте — перебор коэффициента `k` и границ порога.

**Файлы для изменений:**
- `bot/ml/strategy_ml.py` — метод `generate_signal`: расчёт `effective_threshold` от ATR, использование его вместо фиксированного.
- `bot/config.py` — `adaptive_confidence_by_atr`, `adaptive_confidence_k`, `adaptive_confidence_min`, `adaptive_confidence_max`.
- Бэктест: прогон по сетке параметров.

**Приоритет:** Средний  
**Оценка трудозатрат:** 1 день  
**Зависимости:** Нет

---

### 6. Вход по откату (pullback)

**Цель:** Не входить по рынку сразу по сигналу, а ждать откат к скользящей средней или уровню и симулировать лимитный вход.

**Описание:**
- Long: после сигнала Long ждать откат к EMA9/20 или к уровню, например −0.3% от high сигнальной свечи; вход на следующей свече при выполнении условия.
- Short: симметрично — откат вверх к EMA или +0.3%.
- В бэктесте: задержка входа на 1–3 свечи с проверкой условия отката; сравнение с входом «по закрытию сигнальной свечи».

**Файлы для изменений:**
- Новый модуль или блок в `backtest_ml_strategy.py` / отдельный скрипт: логика «сигнал → ожидание N баров → проверка отката → вход».
- Параметры: `pullback_enabled`, `pullback_ema_period`, `pullback_pct`, `pullback_max_bars`.
- При улучшении метрик — перенос в `bot/trading_loop.py` (лимитные ордера или отложенный рыночный вход).

**Приоритет:** Средний  
**Оценка трудозатрат:** 1.5–2 дня  
**Зависимости:** Нет  

**Статус:** ✅ **Реализовано и показало улучшение показателей** — рекомендуется к использованию.
- Бэктест: параметры `--pullback`, `--pullback-ema-period`, `--pullback-pct`, `--pullback-max-bars` в [backtest_ml_strategy.py](backtest_ml_strategy.py).
- Логика: после получения сигнала LONG/SHORT не входим сразу, а ждем откат к EMA9/20 или к уровню (например, -0.3% от high для LONG, +0.3% от low для SHORT).
- Максимальная задержка: 1-3 свечи (настраивается).
- Условия входа: цена коснулась EMA или достигла уровня отката.

**Результаты тестирования на rf_BTCUSDT_15_15m.pkl (30 дней):**
- **Без pullback:** PnL +80.53%, Win Rate 60.13%, Profit Factor 2.32, Sharpe 5.77, сделок 153, убыточных 61
- **С pullback (EMA9, 0.3%, макс. 3 бара):** PnL +83.86% (+3.33%), Win Rate 65.03% (+4.9%), Profit Factor 2.39 (+0.07), Sharpe 5.89 (+0.12), сделок 143 (-10), убыточных 50 (-11)
- **Вывод:** Pullback улучшил качество входов: выше Win Rate, меньше убыточных сделок, выше общая прибыльность. Меньше сделок, но выше качество. Рекомендуется к использованию.

---

### 7. Лимит просадки (daily/weekly cap)

**Цель:** При достижении дневной или недельной просадки выше порога не открывать новые сделки до сброса периода.

**Описание:**
- Считать дневной PnL (от начала календарного дня) и недельный (от понедельника или rolling 7 days).
- Если `daily_drawdown_pct >= X%` или `weekly_drawdown_pct >= Y%` — не открывать новые позиции; текущие можно доводить до SL/TP.
- Параметры: `max_daily_drawdown_pct`, `max_weekly_drawdown_pct`.

**Файлы для изменений:**
- `bot/trading_loop.py` — перед открытием позиции проверка текущей просадки дня/недели; хранение состояния (баланс на начало дня/недели или история сделок).
- Бэктест: тот же лимит в симуляторе (по эквити).
- `bot/config.py` — флаги и пороги.

**Приоритет:** Высокий (риск-менеджмент)  
**Оценка трудозатрат:** 0.5–1 день  
**Зависимости:** Нет

---

### 8. Учёт корреляций между парами

**Цель:** Не дублировать риск: при уже открытом лонге по BTC не открывать лонг по сильно коррелированному альту (или уменьшать размер).

**Описание:**
- Расчёт скользящей корреляции returns пар (например, BTC vs ETH, BTC vs SOL) за N дней.
- Правило: если уже есть открытая позиция по символу A и корреляция A–B выше порога — по символу B не открывать ту же сторону или открывать с уменьшенным размером.
- Параметры: `correlation_lookback_days`, `correlation_threshold`, `reduce_size_factor`.

**Файлы для изменений:**
- Модуль расчёта корреляций (отдельный скрипт или `bot/` утилита), обновление по расписанию или при старте.
- `bot/trading_loop.py` — перед открытием позиции проверка списка открытых и матрицы корреляций.
- `bot/config.py` — включение и пороги.

**Приоритет:** Низкий  
**Оценка трудозатрат:** 1.5–2 дня  
**Зависимости:** Список торгуемых пар, история цен

---

### 9. Feature Engineering (стакан и ликвидации)

**Цель:** Улучшить качество ML-сигналов за счёт данных стакана и/или ликвидаций (если доступно в API).

**Описание:**
- Order Book Imbalance: (bid_volume - ask_volume) / (bid_volume + ask_volume) на глубине N уровней.
- Опционально: объёмы ликвидаций long/short (если Bybit/API отдаёт).
- Добавить фичи в `feature_engineering`, переобучить модели, сравнить метрики в `compare_ml_models.py`.

**Файлы для изменений:**
- `bot/ml/feature_engineering.py` — новые фичи.
- Конфиг/пайплайн обучения — включение новых фичей.
- Проверка API Bybit на наличие данных ликвидаций и стакана в нужной частоте.

**Приоритет:** Средний (долгосрочное качество моделей)  
**Оценка трудозатрат:** 2–3 дня  
**Зависимости:** API, переобучение и бэктест

---

### 10. Динамические веса ансамбля (тренд vs флэт)

**Цель:** В тренде давать больший вес одной группе моделей, во флэте — другой, чтобы улучшить стабильность ансамбля.

**Описание:**
- Классификация режима рынка: тренд (например, ADX > 25) vs флэт (ADX < 20).
- Для каждого режима — свои веса моделей в ансамбле (обученные или подобранные на истории).
- В `generate_signal`: определение режима по текущим данным, выбор весов, предсказание.

**Файлы для изменений:**
- `bot/ml/strategy_ml.py` или класс ансамбля — расчёт режима (ADX и т.п.), переключение весов.
- Обучение/подбор весов по режимам (скрипт в `_deprecated` уже был — можно вынести логику).
- `bot/config.py` — включение и границы ADX.

**Приоритет:** Низкий  
**Оценка трудозатрат:** 2–3 дня  
**Зависимости:** Ансамблевые модели, разметка режимов в истории

---

## Сводная таблица

| # | Улучшение | Приоритет | Трудозатраты | Зависимости |
|---|-----------|-----------|--------------|-------------|
| 1 | Фильтр по волатильности («есть движение») | Высокий | 1–2 дня | — |
| 2 | Тайм-фильтр (торговые часы) | Средний | 0.5–1 день | — |
| 3 | Условный trailing (частичный TP) | Высокий | 1–2 дня | — |
| 4 | Три таймфрейма (4h) | Средний | 2–3 дня | Модели 4h |
| 5 | Адаптивный порог уверенности по ATR | Средний | 1 день | — |
| 6 | Вход по откату (pullback) | Средний | 1.5–2 дня | — |
| 7 | Лимит просадки (daily/weekly) | Высокий | 0.5–1 день | — |
| 8 | Корреляции между парами | Низкий | 1.5–2 дня | Список пар |
| 9 | Фичи стакана/ликвидаций | Средний | 2–3 дня | API, переобучение |
| 10 | Динамические веса ансамбля | Низкий | 2–3 дня | Ансамбль, разметка |

---

## Рекомендуемый порядок внедрения

**Фаза 1 (риск и стабильность):**
- 7 — Лимит просадки  
- 1 — Фильтр по волатильности («есть движение»)  
- 3 — Условный trailing  

**Фаза 2 (качество входа и фильтры):**
- 2 — Тайм-фильтр  
- 5 — Адаптивный порог уверенности  
- 6 — Вход по откату  

**Фаза 3 (расширение логики и данных):**
- 4 — Три таймфрейма (4h)  
- 9 — Фичи стакана/ликвидаций  
- 8 — Корреляции между парами  
- 10 — Динамические веса ансамбля  

---

## Интеграция с оптимизатором

В `auto_strategy_optimizer.py` можно ввести «варианты стратегии»:
- Базовые: MTF, single (как сейчас).
- Дополнительно: MTF + ATR-фильтр, single + торговые часы, single + лимит просадки и т.д.

Выбор лучшей комбинации по символу — по тому же составному счёту (PnL, Win Rate, Profit Factor, Sharpe, Drawdown). Результаты по-прежнему сохранять в `best_strategies_*.json` с указанием применённых фильтров.

---

## Чеклист по каждому улучшению

При реализации каждого пункта отмечать:
- [ ] Описание и параметры добавлены в `bot/config.py`
- [ ] Логика реализована в бэктесте и проверена на истории
- [ ] При необходимости — интеграция в `bot/trading_loop.py`
- [ ] Обновлена документация (этот файл и/или PROFITABILITY_STRATEGY.md)
- [ ] При необходимости — учёт в `auto_strategy_optimizer.py`

---

*Документ создан как единая точка учёта улучшений. Обновляйте статус и приоритеты по мере реализации.*
