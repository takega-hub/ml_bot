# Дорожная карта улучшений торговых стратегий

Документ описывает запланированные улучшения для повышения прибыльности и устойчивости бота. Связан с текущей стратегией: [PROFITABILITY_STRATEGY.md](PROFITABILITY_STRATEGY.md).

**Эталонная модель для тестов:** все новые изменения тестируются на [rf_BTCUSDT_15_15m.pkl](ml_models/rf_BTCUSDT_15_15m.pkl). Подробности: [TESTING_REFERENCE_MODEL.md](TESTING_REFERENCE_MODEL.md).  
**В основном торговом цикле** для всех символов используются переобученные модели из `ml_models/` (в т.ч. [rf_BTCUSDT_15_15m.pkl](ml_models/rf_BTCUSDT_15_15m.pkl)), уже включающие фичи стакана (см. §9).

---

## Текущее состояние системы

| Компонент | Описание |
|-----------|----------|
| **MLStrategy** | Одна модель 15m, порог уверенности, фильтр стабильности, ATR-based SL/TP; опционально динамические веса ансамбля по ADX (тренд/флэт) |
| **MTF** | Фильтр по 1h + вход по 15m, режимы выравнивания (strict/weighted); опционально 4h (эвристика EMA), бусты размера/TP при согласии |
| **Гипотезы** | `hypothesis_test.py`: dynamic (breakeven + trailing), fixed_25_10, fixed_15_5, fixed_10_10 |
| **Оптимизатор** | `auto_strategy_optimizer.py` — выбор MTF vs single по символу, сохранение в `best_strategies_*.json` |
| **Бэктесты** | `backtest_ml_strategy.py`, `backtest_mtf_strategy.py`, `backtest_tp_reentry_delay.py`; тест динамических весов: `scripts/test_dynamic_ensemble_weights.py` |

---

## Улучшения (список)

### 1. Фильтр по волатильности (торговать только когда «есть движение»)

**Цель:** Торговать только когда волатильность в «рабочем» диапазоне — не флэт (мало движения) и не паника (слишком большой шум). Иными словами: входить только когда «есть движение».

**Описание:**
- Считать **ATR(14)** или **BB width** (ширину Bollinger Bands) на таймфрейме **1h**.
- Входить только если волатильность попадает в заданный диапазон: не слишком низкая (флэт) и не слишком высокая (паника).
- В бэктесте **перебирать пороги** (например, 0.3%–2.0% для ATR в процентах от цены) и смотреть **PnL / Sharpe** по каждому варианту; выбрать лучшую пару min/max по символам или глобально.

**Где внедрить (варианты):**
- **Обёртка над MLStrategy** — отдельный класс/функция, которая принимает сигнал от MLStrategy и пропускает его дальше только если ATR 1h в диапазоне.
- **Фильтр в `trading_loop`** — перед открытием позиции проверять ATR(14) или BB width на 1h; при выходе за диапазон не открывать сделку.

**Файлы для изменений:**
- `backtest_ml_strategy.py` или `backtest_mtf_strategy.py` — расчёт ATR(14) или BB width на 1h, фильтр перед открытием позиции; перебор порогов 0.3–2.0% и вывод PnL/Sharpe.
- При успехе: `bot/trading_loop.py` — тот же фильтр в live; `bot/config.py` — параметры `atr_filter_enabled`, `atr_min_pct`, `atr_max_pct` (и при использовании BB — `bb_width_period`, `bb_width_min`, `bb_width_max`).

**Приоритет:** Высокий  
**Оценка трудозатрат:** 1–2 дня  
**Зависимости:** Нет  

**Статус:** ⚠️ **Реализовано, но показало ухудшение показателей** — не рекомендуется к использованию. Конфиг: `atr_filter_enabled`, `atr_min_pct`, `atr_max_pct` в [bot/config.py](bot/config.py). Бэктест: флаг `--atr-filter`, `--atr-min`, `--atr-max` в [backtest_ml_strategy.py](backtest_ml_strategy.py). Live: проверка в [bot/trading_loop.py](bot/trading_loop.py) перед открытием позиции. **По умолчанию отключен** (`atr_filter_enabled: false`). При тестировании показал снижение прибыльности, возможно из-за пропуска прибыльных сигналов в периоды низкой/высокой волатильности.

---

### 2. Тайм-фильтр (торговые часы)

**Цель:** Ограничить торговлю часами с нормальной ликвидностью и объёмом, снизить входы в «мёртвые» сессии.

**Описание:**
- Параметры: время начала и конца в UTC (например, 08:00–20:00).
- В бэктесте: сигналы вне окна не приводят к открытию позиции.
- Сравнить метрики: «все часы» vs «только окно».

**Файлы для изменений:**
- `backtest_ml_strategy.py`, `backtest_mtf_strategy.py` — проверка `datetime` входа в диапазон.
- `bot/trading_loop.py` — проверка перед открытием.
- `bot/config.py` — `trading_hours_enabled`, `trading_hour_start_utc`, `trading_hour_end_utc`.

**Приоритет:** Средний  
**Оценка трудозатрат:** 0.5–1 день  
**Зависимости:** Нет

---

### 3. Условный trailing (частичный TP + трейлинг)

**Цель:** Зафиксировать часть прибыли по первой цели, затем вести трейлинг по остатку, чтобы не отдавать уже заработанное.

**Описание:**
- Первая цель: например +1.5% — переводим SL в breakeven или закрываем часть позиции.
- После достижения порога активации (например, +3%) — включать классический trailing (как в `hypothesis_test` dynamic).
- Параметры: `partial_tp_pct`, `trailing_activation_pct`, `trailing_distance_pct`.

**Файлы для изменений:**
- `hypothesis_test.py` — новый режим, например `dynamic_partial_tp`, или расширение `HypothesisSimulator`.
- `backtest_ml_strategy.py` / `MLBacktestSimulator` — при наличии единого симулятора выхода: логика частичного TP + трейлинг.
- Документация: добавить описание режима в этот файл и в PROFITABILITY_STRATEGY.md.

**Приоритет:** Высокий  
**Оценка трудозатрат:** 1–2 дня  
**Зависимости:** Нет  

**Статус:** ⚠️ **Реализовано, но показало ухудшение показателей** — не рекомендуется к использованию. 
- Бэктест: параметры `--partial-tp`, `--partial-tp-pct`, `--trailing-activation-pct`, `--trailing-distance-pct` в [backtest_ml_strategy.py](backtest_ml_strategy.py).
- Режим `dynamic_partial_tp` добавлен в [hypothesis_test.py](hypothesis_test.py).
- Логика: при достижении `partial_tp_pct` (по умолчанию 1.5%) SL переводится в breakeven; при достижении `trailing_activation_pct` (по умолчанию 3.0%) активируется trailing stop с расстоянием `trailing_distance_pct` (по умолчанию 2.0%).

**Результаты тестирования на rf_BTCUSDT_15_15m.pkl (30 дней):**
- **Без частичного TP:** PnL +79.74%, Win Rate 60.13%, Profit Factor 2.30, Sharpe 5.72, Max DD 5.58%, сделок 153
- **С частичным TP:** PnL +61.01% (-18.73%), Win Rate 51.89% (-8.24%), Profit Factor 1.88 (-0.42), Sharpe 4.22 (-1.50), Max DD 8.26% (+2.68%), сделок 185 (+32)
- **Вывод:** Частичный TP увеличил количество сделок и убыточных сделок, снизил Win Rate и общую прибыльность. Возможные причины: слишком ранний breakeven (1.5%) приводит к преждевременным закрытиям, trailing stop на расстоянии 2.0% слишком близко и срабатывает на коррекциях.

---

### 4. Три таймфрейма (добавление 4h)

**Цель:** Усилить фильтр тренда: вход только при согласованности 4h, 1h и 15m; при согласии — возможность увеличить размер или расширить TP.

**Описание:**
- Текущий MTF: 1h (фильтр) + 15m (вход). Добавить 4h как «тренд высшего порядка».
- Правила: при совпадении направления 4h и 1h с 15m — разрешать вход и опционально повышать долю риска или целевой TP; при несовпадении 4h — не входить или уменьшать размер.
- Модель 4h: либо отдельная обученная модель, либо эвристика (например, EMA 50/200 на 4h).

**Файлы для изменений:**
- `bot/ml/mtf_strategy.py` — класс `MultiTimeframeMLStrategy`: добавление 4h, флаги `require_4h_alignment`, `boost_size_on_4h_align`.
- Обучение/подбор моделей 4h (если решено использовать ML на 4h).
- `auto_strategy_optimizer.py` — учёт 4h в переборе комбинаций (если нужно).
- `bot/config.py` — параметры 4h (вкл/выкл, пороги).

**Приоритет:** Средний  
**Оценка трудозатрат:** 2–3 дня  
**Зависимости:** Модели/данные 4h  

**Статус:** ✅ Реализовано с эвристикой (EMA 50/200, при нехватке данных — EMA 20/50).
- Добавлена поддержка 4h таймфрейма в [bot/ml/mtf_strategy.py](bot/ml/mtf_strategy.py) с эвристикой EMA 50/200.
- Логика: при включении `enable_4h` проверяется направление тренда на 4h; при `require_4h_alignment=True` вход разрешен только при согласии всех трех таймфреймов (4h, 1h, 15m).
- При согласии всех трех таймфреймов: опционально увеличивается размер позиции (`boost_size_on_4h_align`, множитель `size_boost_factor`) или расширяется TP (`boost_tp_on_4h_align`, множитель `tp_boost_factor`).
- Бэктест: параметры `--enable-4h`, `--no-require-4h-alignment`, `--boost-size-on-4h`, `--boost-tp-on-4h`, `--size-boost-factor`, `--tp-boost-factor` в [backtest_mtf_strategy.py](backtest_mtf_strategy.py).
- **Исправление (почему не было разницы с/без 4h):** при бэктесте на 30 днях 15m дают ~180 свечей 4h, а в коде требовалось минимум 200 для EMA 200 — 4h никогда не активировался. В [bot/ml/mtf_strategy.py](bot/ml/mtf_strategy.py) добавлен fallback: при `len(df_4h) < 200` используется пара EMA 20/50 (минимум 50 баров 4h), так что при 30 днях 4h-эвристика и бусты теперь применяются. Перезапустите бэктест с `--enable-4h --boost-size-on-4h --boost-tp-on-4h`, чтобы увидеть разницу.

---

### 5. Адаптивный порог уверенности по ATR

**Цель:** В высокой волатильности чуть снижать порог уверенности (больше сигналов в движении), в низкой — повышать (меньше шума).

**Описание:**
- В `generate_signal`: расчёт множителя порога от ATR (например, нормализация к медианному ATR за 30 дней).
- Формула-пример: `effective_threshold = base_threshold * (1 + k * (atr_median - atr_current) / atr_median)`, с ограничением по min/max.
- В бэктесте — перебор коэффициента `k` и границ порога.

**Файлы для изменений:**
- `bot/ml/strategy_ml.py` — метод `generate_signal`: расчёт `effective_threshold` от ATR, использование его вместо фиксированного.
- `bot/config.py` — `adaptive_confidence_by_atr`, `adaptive_confidence_k`, `adaptive_confidence_min`, `adaptive_confidence_max`.
- Бэктест: прогон по сетке параметров.

**Приоритет:** Средний  
**Оценка трудозатрат:** 1 день  
**Зависимости:** Нет  

**Статус:** ⚠️ **Реализовано** — на 30 днях ухудшение, на 60 днях небольшое улучшение; по умолчанию выключен.
- В [bot/ml/strategy_ml.py](bot/ml/strategy_ml.py): при `use_adaptive_confidence_by_atr=True` порог считается по формуле от медианы ATR (последние 500 баров) и текущего `atr_pct`; множитель ограничивается `adaptive_confidence_min` / `adaptive_confidence_max`.
- В [bot/config.py](bot/config.py): параметры `use_adaptive_confidence_by_atr`, `adaptive_confidence_k`, `adaptive_confidence_min`, `adaptive_confidence_max`, `adaptive_confidence_atr_lookback`.
- Тест: [scripts/test_adaptive_confidence_atr.py](scripts/test_adaptive_confidence_atr.py).

**Результаты тестирования (30 дней, rf_BTCUSDT_15_15m.pkl, k=0.3, множитель [0.8, 1.2]):**
- **Baseline (фикс. порог):** 159 сделок, Win Rate 60.4%, PnL $81.51 (+1.63%), Sharpe 5.75
- **ATR-адаптивный порог:** 158 сделок, Win Rate 58.9%, PnL $77.35 (+1.55%), Sharpe 5.44
- **Вывод:** На 30 днях фиксированный порог лучше; адаптация по ATR слегка снизила PnL и Sharpe.

**Результаты тестирования (60 дней, triple_ensemble_BTCUSDT_15_15m.pkl, k=0.4, множитель [0.85, 1.15]):**
- **Baseline (фикс. порог):** 285 сделок, Win Rate 63.9%, PnL $126.58 (+2.53%), Sharpe 6.00
- **ATR-адаптивный порог:** 284 сделок, Win Rate 64.1%, PnL $127.83 (+2.56%), Sharpe 6.08
- **Вывод:** На 60 днях ATR-адаптивный порог дал небольшое улучшение (PnL +$1.25, Sharpe +0.08). Имеет смысл пробовать включение на длинных периодах или другие k/min/max.

---

### 6. Вход по откату (pullback)

**Цель:** Не входить по рынку сразу по сигналу, а ждать откат к скользящей средней или уровню и симулировать лимитный вход.

**Описание:**
- Long: после сигнала Long ждать откат к EMA9/20 или к уровню, например −0.3% от high сигнальной свечи; вход на следующей свече при выполнении условия.
- Short: симметрично — откат вверх к EMA или +0.3%.
- В бэктесте: задержка входа на 1–3 свечи с проверкой условия отката; сравнение с входом «по закрытию сигнальной свечи».

**Файлы для изменений:**
- Новый модуль или блок в `backtest_ml_strategy.py` / отдельный скрипт: логика «сигнал → ожидание N баров → проверка отката → вход».
- Параметры: `pullback_enabled`, `pullback_ema_period`, `pullback_pct`, `pullback_max_bars`.
- При улучшении метрик — перенос в `bot/trading_loop.py` (лимитные ордера или отложенный рыночный вход).

**Приоритет:** Средний  
**Оценка трудозатрат:** 1.5–2 дня  
**Зависимости:** Нет  

**Статус:** ✅ **Реализовано и показало улучшение показателей** — рекомендуется к использованию.
- Бэктест: параметры `--pullback`, `--pullback-ema-period`, `--pullback-pct`, `--pullback-max-bars` в [backtest_ml_strategy.py](backtest_ml_strategy.py).
- Логика: после получения сигнала LONG/SHORT не входим сразу, а ждем откат к EMA9/20 или к уровню (например, -0.3% от high для LONG, +0.3% от low для SHORT).
- Максимальная задержка: 1-3 свечи (настраивается).
- Условия входа: цена коснулась EMA или достигла уровня отката.

**Результаты тестирования на rf_BTCUSDT_15_15m.pkl (30 дней):**
- **Без pullback:** PnL +80.53%, Win Rate 60.13%, Profit Factor 2.32, Sharpe 5.77, сделок 153, убыточных 61
- **С pullback (EMA9, 0.3%, макс. 3 бара):** PnL +83.86% (+3.33%), Win Rate 65.03% (+4.9%), Profit Factor 2.39 (+0.07), Sharpe 5.89 (+0.12), сделок 143 (-10), убыточных 50 (-11)
- **Вывод:** Pullback улучшил качество входов: выше Win Rate, меньше убыточных сделок, выше общая прибыльность. Меньше сделок, но выше качество. Рекомендуется к использованию.

---

### 7. Лимит просадки (daily/weekly cap)

**Цель:** При достижении дневной или недельной просадки выше порога не открывать новые сделки до сброса периода.

**Описание:**
- Считать дневной PnL (от начала календарного дня) и недельный (от понедельника или rolling 7 days).
- Если `daily_drawdown_pct >= X%` или `weekly_drawdown_pct >= Y%` — не открывать новые позиции; текущие можно доводить до SL/TP.
- Параметры: `max_daily_drawdown_pct`, `max_weekly_drawdown_pct`.

**Файлы для изменений:**
- `bot/trading_loop.py` — перед открытием позиции проверка текущей просадки дня/недели; хранение состояния (баланс на начало дня/недели или история сделок).
- Бэктест: тот же лимит в симуляторе (по эквити).
- `bot/config.py` — флаги и пороги.

**Приоритет:** Высокий (риск-менеджмент)  
**Оценка трудозатрат:** 0.5–1 день  
**Зависимости:** Нет

---

### 8. Учёт корреляций между парами

**Цель:** Не дублировать риск: при уже открытом лонге по BTC не открывать лонг по сильно коррелированному альту (или уменьшать размер).

**Описание:**
- Расчёт скользящей корреляции returns пар (например, BTC vs ETH, BTC vs SOL) за N дней.
- Правило: если уже есть открытая позиция по символу A и корреляция A–B выше порога — по символу B не открывать ту же сторону или открывать с уменьшенным размером.
- Параметры: `correlation_lookback_days`, `correlation_threshold`, `reduce_size_factor`.

**Файлы для изменений:**
- Модуль расчёта корреляций (отдельный скрипт или `bot/` утилита), обновление по расписанию или при старте.
- `bot/trading_loop.py` — перед открытием позиции проверка списка открытых и матрицы корреляций.
- `bot/config.py` — включение и пороги.

**Приоритет:** Низкий  
**Оценка трудозатрат:** 1.5–2 дня  
**Зависимости:** Список торгуемых пар, история цен

---

### 9. Feature Engineering (стакан)

**Цель:** Улучшить качество ML-сигналов за счёт данных стакана заявок (Bybit REST API даёт стакан; ликвидации на данном этапе не отслеживаем).

**Описание:**
- Order Book Imbalance: (bid_volume - ask_volume) / (bid_volume + ask_volume) на глубине N уровней (REST `/v5/market/orderbook`, в проекте уже есть `BybitClient.get_orderbook`).
- Добавить фичи в `feature_engineering`, переобучить модели, сравнить метрики в `compare_ml_models.py`.

**Файлы для изменений:**
- `bot/ml/feature_engineering.py` — новые фичи.
- Конфиг/пайплайн обучения — включение новых фичей.

**Приоритет:** Средний (долгосрочное качество моделей)  
**Оценка трудозатрат:** 2–3 дня  
**Зависимости:** переобучение и бэктест  

**Статус:** ✅ Реализовано (базовая поддержка).
- В [bot/ml/feature_engineering.py](bot/ml/feature_engineering.py) добавлены:
  - Функция `compute_orderbook_imbalance(ob_response, depth)` — расчёт (bid_volume - ask_volume) / (bid_volume + ask_volume) из ответа Bybit `/v5/market/orderbook`.
  - В `create_technical_indicators()` колонки `ob_imbalance`, `ob_imbalance_5`, `ob_imbalance_20` (в истории = 0; для live можно подставить реальные значения через `set_orderbook_imbalance_last_row()`).
  - Метод `set_orderbook_imbalance_last_row(df, ob_response, depth)` — заполнение последней строки для live.
- В исторических данных стакана нет — при обучении и бэктесте фичи = 0. После переобучения модели будут содержать эти фичи; в live при наличии вызова `get_orderbook` можно подставлять реальный стакан в последнюю строку перед предсказанием.
- Проверка: `python scripts/test_orderbook_feature.py`. Для теста обучения/бэктеста: переобучить модель (например, `retrain_ml_optimized.py` или аналог), затем `compare_ml_models.py` или `backtest_ml_strategy.py`.

**Обучение RF для BTC и сравнение с обычной моделью:**
1. Обучить новую RF с текущим набором фичей (включая ob_imbalance), сохранить под другим именем, чтобы не перезаписать эталон:
   ```bash
   python retrain_ml_optimized.py --symbol BTCUSDT --no-mtf --model-suffix _ob
   ```
   Будет создана модель `rf_BTCUSDT_15_15m_ob.pkl` (эталонная `rf_BTCUSDT_15_15m.pkl` не перезаписывается).
2. Сравнить на одном периоде одной командой:
   ```bash
   python scripts/compare_two_models.py ml_models/rf_BTCUSDT_15_15m.pkl ml_models/rf_BTCUSDT_15_15m_ob.pkl --symbol BTCUSDT --days 30
   ```
   С pullback (как в live): добавить флаг `--pullback`.

**Внедрение в основной торговый цикл (зафиксировано):**
- Ранее для BTC использовалась отдельная модель **rf_BTCUSDT_15_15m_ob.pkl**; бэктест (30 дней) показывал улучшение: без pullback +11.31$ PnL, Win Rate +4.72%, с pullback +4.55$ PnL, Win Rate +1.43%.
- В [bot/config.py](bot/config.py) и [bot/trading_loop.py](bot/trading_loop.py) для символов из `PREFER_OB_MODEL_FOR_SYMBOLS` при выборе модели предпочитается файл с суффиксом `_ob`, если он есть в `ml_models/` (актуально, когда в папке есть и старая, и новая модель).

**Переобучение по всем символам (текущее состояние):**
- **Все модели переобучены и перезаписаны без суффикса _ob.** Текущие файлы в `ml_models/` (например, [rf_BTCUSDT_15_15m.pkl](ml_models/rf_BTCUSDT_15_15m.pkl) и аналоги по другим символам/ТФ) уже содержат фичи стакана (`ob_imbalance`, `ob_imbalance_5`, `ob_imbalance_20`). Отдельные файлы `*_ob.pkl` не используются — везде используются обновлённые модели без суффикса.
- **Тестирование в процессе;** результаты будут добавлены в роадмэп после проверки.
- При любом следующем переобучении в обучение по-прежнему попадают все текущие фичи из [bot/ml/feature_engineering.py](bot/ml/feature_engineering.py). Команда для переобучения по всем активным символам и таймфреймам (15m и 1h):  
  `python retrain_ml_optimized.py --all-active --all-intervals --no-mtf`

---

### 10. Динамические веса ансамбля (тренд vs флэт)

**Цель:** В тренде давать больший вес одной группе моделей, во флэте — другой, чтобы улучшить стабильность ансамбля.

**Описание:**
- Классификация режима рынка: тренд (например, ADX > 25) vs флэт (ADX < 20).
- Для каждого режима — свои веса моделей в ансамбле (обученные или подобранные на истории).
- В `generate_signal`: определение режима по текущим данным, выбор весов, предсказание.

**Файлы для изменений:**
- `bot/ml/strategy_ml.py` или класс ансамбля — расчёт режима (ADX и т.п.), переключение весов.
- Обучение/подбор весов по режимам (скрипт в `_deprecated` уже был — можно вынести логику).
- `bot/config.py` — включение и границы ADX.

**Приоритет:** Низкий  
**Оценка трудозатрат:** 2–3 дня  
**Зависимости:** Ансамблевые модели, разметка режимов в истории  

**Статус:** ✅ **Реализовано и показало улучшение на тесте** — рекомендуется для ансамблевых моделей.
- В [bot/ml/model_trainer.py](bot/ml/model_trainer.py): у `WeightedEnsemble`, `TripleEnsemble`, `QuadEnsemble` добавлен аргумент `weights_override` в `predict_proba()` для переключения весов по режиму.
- В [bot/ml/strategy_ml.py](bot/ml/strategy_ml.py): в `predict()` по ADX последней свечи выбирается режим (тренд / флэт) и передаётся соответствующий `weights_override` в ансамбль. Параметры: `use_dynamic_ensemble_weights`, `adx_trend_threshold`, `adx_flat_threshold`, `trend_weights`, `flat_weights`.
- В [bot/config.py](bot/config.py): параметры в `StrategyParams`; загрузка из `ml_settings.json`. В [bot/trading_loop.py](bot/trading_loop.py) и [bot/ml/mtf_strategy.py](bot/ml/mtf_strategy.py) стратегии создаются с этими параметрами.
- Тест: [scripts/test_dynamic_ensemble_weights.py](scripts/test_dynamic_ensemble_weights.py) — сравнение baseline vs динамические веса.

**Результаты тестирования (triple_ensemble_BTCUSDT_15_15m.pkl, 30 дней):**
- **Baseline (фикс. веса):** PnL $98.98 (+1.98%), Win Rate 66.24%, Sharpe 7.21, сделок 157
- **Dynamic (тренд/флэт по ADX):** PnL $100.76 (+2.02%), Win Rate 66.24%, Sharpe 7.36, сделок 157
- **Вывод:** Динамические веса дали прирост PnL и Sharpe при том же числе сделок. Включение: в `ml_settings.json` задать `"use_dynamic_ensemble_weights": true` и словари `trend_weights` / `flat_weights` (для triple: rf_weight, xgb_weight, lgb_weight; для quad — добавить lstm_weight).

---

## Сводная таблица

| # | Улучшение | Приоритет | Трудозатраты | Зависимости | Статус | Результат теста |
|---|-----------|-----------|--------------|-------------|--------|------------------|
| 1 | Фильтр по волатильности («есть движение») | Высокий | 1–2 дня | — | ⚠️ Реализовано | Ухудшение — по умолчанию выключен |
| 2 | Тайм-фильтр (торговые часы) | Средний | 0.5–1 день | — | — | Не тестировалось |
| 3 | Условный trailing (частичный TP) | Высокий | 1–2 дня | — | ⚠️ Реализовано | Ухудшение (WR −8%, PnL −18%) — не рекомендуется |
| 4 | Три таймфрейма (4h) | Средний | 2–3 дня | Модели/эвристика 4h | ✅ Реализовано | Эвристика EMA 50/200; бусты при согласии 4h/1h/15m |
| 5 | Адаптивный порог уверенности по ATR | Средний | 1 день | — | ⚠️ Реализовано | 30 д: ухудшение (PnL −$4, Sharpe −0.31). 60 д: небольшое улучшение (PnL +$1.25, Sharpe +0.08) — по умолчанию выкл. |
| 6 | Вход по откату (pullback) | Средний | 1.5–2 дня | — | ✅ Реализовано | Улучшение (PnL +3.33%, WR +4.9%) — рекомендуется |
| 7 | Лимит просадки (daily/weekly) | Высокий | 0.5–1 день | — | — | Не тестировалось |
| 8 | Корреляции между парами | Низкий | 1.5–2 дня | Список пар | — | Не тестировалось |
| 9 | Фичи стакана (Order Book Imbalance) | Средний | 2–3 дня | переобучение, бэктест | ✅ Реализовано | Для BTC предпочитается _ob модель в live |
| 10 | Динамические веса ансамбля | Низкий | 2–3 дня | Ансамбль | ✅ Реализовано | Улучшение (PnL +$1.78, Sharpe +0.15) — рекомендуется для ансамблей |

---

## Рекомендуемый порядок внедрения

**Уже в основном цикле:** 4 (4h), 6 (pullback), 9 (стакан для BTC), 10 (динамические веса ансамбля — включается через `ml_settings.json`).

**Фаза 1 (риск и стабильность):**
- 7 — Лимит просадки (daily/weekly)  
- 1 — Фильтр по волатильности — реализован, по умолчанию выключен (тест показал ухудшение)  
- 3 — Условный trailing — реализован, не рекомендуется (тест показал ухудшение)  

**Фаза 2 (качество входа и фильтры):**
- 2 — Тайм-фильтр (торговые часы)  
- 5 — Адаптивный порог уверенности по ATR  
- 6 — Вход по откату — ✅ в цикле, рекомендуется  

**Фаза 3 (расширение логики и данных):**
- 4 — Три таймфрейма (4h) — ✅ в цикле (MTF + 4h эвристика)  
- 9 — Фичи стакана — ✅ в цикле для BTCUSDT (модель _ob)  
- 8 — Корреляции между парами  
- 10 — Динамические веса ансамбля — ✅ в цикле, включение через `ml_settings.json`  

---

## Интеграция с оптимизатором

В `auto_strategy_optimizer.py` можно ввести «варианты стратегии»:
- Базовые: MTF, single (как сейчас).
- Дополнительно: MTF + ATR-фильтр, single + торговые часы, single + лимит просадки и т.д.

Выбор лучшей комбинации по символу — по тому же составному счёту (PnL, Win Rate, Profit Factor, Sharpe, Drawdown). Результаты по-прежнему сохранять в `best_strategies_*.json` с указанием применённых фильтров.

---

## Чеклист по каждому улучшению

При реализации каждого пункта отмечать:
- [ ] Описание и параметры добавлены в `bot/config.py`
- [ ] Логика реализована в бэктесте и проверена на истории
- [ ] При необходимости — интеграция в `bot/trading_loop.py`
- [ ] Обновлена документация (этот файл и/или PROFITABILITY_STRATEGY.md)
- [ ] При необходимости — учёт в `auto_strategy_optimizer.py`

---

*Документ создан как единая точка учёта улучшений. Обновляйте статус и приоритеты по мере реализации.*
